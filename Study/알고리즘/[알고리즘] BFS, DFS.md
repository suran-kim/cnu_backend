# [알고리즘] BFS, DFS

Created: 2022년 9월 21일 오후 2:46
Last Edited Time: 2022년 9월 21일 오후 8:53

> *이것이 코딩테스트다 with 파이썬(나동빈 저)를 읽고 정리한 기록입니다.*
> 

# 요약

---

BFS, DFS는 그래프를 탐색하기 위한 대표적인 두 가지 알고리즘이다. 

# 사전 학습 개념

---

`DFS/BFS`를 학습하기 전 알아야 할 중요한 개념이 있다. 바로 `스택`, `큐`, `재귀함수`이다. 

## 스택

후입선출

## 큐

선입선출

공정한 자료구조 

## 재귀 함수

`재귀함수`는 내부적으로 `스택 자료구조`와 동일하다. 따라서 `스택 자료구조`를 활용해야 하는 상당수 알고리즘은 `재귀함수`를 이용해서 간편하게 구현될 수 있다. 

`재귀 함수` 내에서 특정 조건일 때 더 이상 재귀적으로 함수를 호출하지 않고 종료하도록 if문을 이용해서 꼭 `종료 조건`을 구현해줘야 한다.

# DFS/BFS

---

그럼 이제 본격적으로 DFS, BFS알고리즘에 대해 알아보자. DFS와 BFS는 `그래프 탐색`을 위해 사용되는 `탐색 알고리즘`이다. 

`Depth-First Search`알고리즘은 `깊이 우선 탐색`이라고도 부르며, 그래프에서 `깊은 부분`을 우선적으로 탐색한다.

`Breadth First Search` 알고리즘은 `너비 우선 탐색`이라는 의미를 가지며, `가까운 노드`부터 탐색한다.

## 그래프

---

`그래프`의 기본 구조를 살펴보자.

그래프는 `정점(node)`와 `간선(edge)`으로 이루어진 `자료구조`이다. 

`그래프 탐색`이란 하나의 노드를 시작으로 다수의 노드를 방문하는 것을 말한다. 

두 노드가 간선으로 연결되어 있다면 `두 노드는 인접하다`고 표현한다.

 

프로그래밍에서 그래프는 2가지 방식으로 표현할 수 있다.

- 인접 행렬 : `2차원 배열`로 그래프의 연결 관계를 표현하는 방식
- 인접 리스트 : `리스트`로 그래프의 연결 관계를 표현하는 방식

## DFS

---

`Depth-First Search`알고리즘은 `깊이 우선 탐색`이라고도 부르며, 그래프에서 `깊은 부분`을 우선적으로 탐색한다. 즉, 최대한 `멀리 있는 노드`를 우선으로 탐색하는 방식이다.

DFS는 스택 자료 구조를 사용하며 구체적인 동작 과정은 다음과 같다.

1. 탐색 시작 노드를 스택에 삽입하고 `방문 처리`를 한다.
2. 스택의 최상단 노드에 방문하지 않은 인접 노드가 있으면 그 인접 노드를 스택에 넣고 `방문 처리`를 한다. 방문하지 않은 인접 노드가 없으면 스택에서 최상단 노드를 꺼낸다.
3. 2번의 과정을 더 이상 수행할 수 없을 때까지 반복한다. 

여기서 `방문 처리`란, 스택에 한 번 삽입되어 처리된 노드가 다시 삽입되지 않도록 체크하는 것을 의미한다. 방문 처리를 하면 각 노드를 한 번씩만 처리할 수 있다.

깊이 우선 탐색 알고리즘 `DFS`는 스택 자료구조에 기초한다는 점에서 구현이 간단하다. 탐색을 수행함에 있어서 데이터의 개수가 N개인 경우 `O(N)`의 시간이 소요된다. 

또, `DFS`는 `스택`을 이용하는 알고리즘이기 때문에 실제 구현은 `재귀 함수`를 이용했을 때 매우 간결해질 수 있다.

## BFS

---

`Breadth First Search` 알고리즘은 `너비 우선 탐색`이라는 의미를 가지며, `가까운 노드`부터 탐색하는 알고리즘이다. 

BFS는 선입선출 방식인 `큐` 자료구조를 이용하는 것이 정석이다. 인접한 노드를 반복적으로 큐에 넣도록 알고리즘을 작성하면 자연스럽게 먼저 들어온 것이 먼저 나가게 되어, 가까운 노드부터 탐색을 진행하게 된다. 

BFS의 구체적인 동작 과정은 다음과 같다.

1. 탐색 시작 노드를 큐에 삽입하고 `방문 처리`를 한다.
2. 큐에서 노드를 꺼내 해당 노드의 인접 노드 중에서 방문하지 않은 노드를 모두 큐에 삽입하고 `방문 처리`를 한다.
3. 2번의 과정을 더 이상 수행할 수 없을 때까지 반복한다. 

너비 우선 탐색 알고리즘 `BFS`는 `큐` 자료구조에 기초한다는 점에서 구현이 간단하다. 탐색을 수행함에 있어 `DFS`와 마찬가지로 `O(N)`의 시간이 소요된다. 

일반적인 경우 실제 수행 시간은 `DFS`보다 좋은 편이다. 

# 풀이 팁

---

`1차원 배열`이나 `2차원 배열`을 그래프 형태로 생각하면 수월하게 문제를 풀 수 있다. 

3x3 형태의 2차원 배열이 있다고 할 때, 모든 좌표의 형태를 다음처럼 그래프의 형태로 바꿔서 생각할 수 있다.

특히 코딩테스트에서 2차원 배열에서의 탐색 문제를 만났을 때 그래프 형태로 바꿔서 생각하면 풀이 방법을 조금 더 쉽게 떠올릴 수 있다. 그러므로 코딩 테스트에서 탐색 문제를 보면 그래프 형태로 표현한 다음 풀이법을 고민하도록 하자.

# 정리

---

***DFS***

모든 노드를 방문하고자 하는 경우에 사용한다.

`깊이 우선 탐색(DFS)`이 `너비 우선 탐색(BFS)`보다 좀 더 간단하다.

검색 속도 자체는 `너비 우선 탐색(BFS)`에 비해서 느리다.

***BFS*** 

두 노드 사이의 최단 경로를 찾고싶을 때 사용

DFS, BFS은 특징에 따라 사용에 더 적합한 문제 유형들이 있다.

- 그래프의 모든 정점을 방문하는 것이 주요한 문제 (***DFS, BFS***)
- 경로의 특징을 저장해둬야 하는 문제 (***DFS***)
- 최단거리를 구해야 하는 문제 (***BFS***)

---

***Rf***

이것이 코딩테스트다 with 파이썬(저자 나동빈)

****[DFS, BFS의 설명, 차이점](https://velog.io/@lucky-korma/DFS-BFS%EC%9D%98-%EC%84%A4%EB%AA%85-%EC%B0%A8%EC%9D%B4%EC%A0%90)****

[Java 인접행렬과 인접리스트를 이용하여 그래프 구현하기](https://freestrokes.tistory.com/87)